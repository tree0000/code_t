<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    배열
    리터널을 이용하는 방법
    배열 생성자를 이용하는 방법
    Array.fill()함수를 이용하는 방법

    배열의 인덱스는 0부터 시작합니다.
    배열은 차원과는 무관하게 메모리에 연속 할당된다.

    1차원배열
    배열의 각 데이터는 메모리의 낮은 조소에서 높은 주소방향으로 연이어 할당
    2차원배열
    데이터 접근 방식은 1차원 배열과 비슷하지만 []를 2개 활용 
    
    효율성
    배열연산의 시간 복잡도 
    배열은 임의 접근이라는 방법으로 배열의 모든 위치에 있는 데이터에 단 한번에 
    접근할 수있다.

    맨 뒤 삽입
    다른 위치에 영향을 주지 않으므로 O(1)이다.

    맨 앞 삽입
    데이터를  한칸씩 밀어야 하므로 O(n)이다.

    중간 삽입
    삽입한 데이터 뒤에 있는 데이터 개수만큼 연산을 해여함 O(n)이다.

    고려
    할당할 수 있는 메모리 크기를 확인 
    중간에 데이터 삽입이 많은지 확인 (배열은 자료구조이기 떄문에 시간 복잡도 가 높아질수 있다.)

<script>
    //push()로 추가
    const arr = [1,2,3]
    arr.push(4);

    //concat()로 추가
    let arr2 = [1,2,3];
    arr = arr.concat([4,5])

    //스프레드 연산자로 추가
    let arr3 = [1,2,3];
    arr = [...arr, ...[4,5]]

    //unshift() 연산자로 추가
    const arr4 = [1,2,3];
    arr.unshift(0);

    //splice() 메서드로 추가
    const arr5 = [1, 2, 3, 4, 5];
    arr5.splice(2, 0, 999); 

    //배열에서 데이터 삭제

    //pop() 메서드 사용(가장 마지막 데이터를 삭제하고 반환)
    const arr6 =[1,2,3,4,5];
    const poppedElement = arr6.pop();

    //shift() 메서드 사용 (맨 앞 데이터를 삭제하고 반환)
    const arr7 = [1,2,3,4,5];
    const shiftElement = arr7.shift();

    //splice() 메서드 사용(중간 데이터를 삭제)
    const arr8 = [1,2,3,4,5];
    const removedElements = arr. splice(2,2);

    // 고차 함수를 이용하여 특정 연산을 적용

    //배열에 제곱연산 적용 (map)
    const numbers = [1,2,3,4,5];
    const squares = numbers.amp(num => num *num);

    //짝수 필터링 (filter())
    const numbers2 = [1,2,3,4,5]
    const evens = numbers.filter(num % 2 === 0);

    //전체 합 (reduce())
    //reduce는 익명함수가 받아야하는 인수가 2개이다 .
    const numbers3 =[1,2,3,4,5];
    const sum = numbers.reduce((a,b)=> a + b);


    function solution(queue1, queue2) {


const sumQueue = (arr) => arr.reduce((a, b) => a + b, 0);

    let sum1 = sumQueue(queue1);
    let sum2 = sumQueue(queue2);
    const total = sum1 + sum2;
    if (total % 2 !== 0) {
        return -1;
    }
    const target = total / 2;
    let count = 0;
    let left = 0;
    let right = queue1.length - 1;
    while (sum1 !== target) {
        if (sum1 < target) {
            right++;
            if (right === queue1.length) {
                right = 0;
            }
            sum1 += queue2[right];
        } else {
            sum1 -= queue1[left];
            left++;
            if (left === queue1.length) {
                left = 0;
            }
        }
        count++;
        if (count > queue1.length * 3) {
            return -1;
        }
    }
    return count;
    







}

</script>
</body>
</html>