<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*
        배열 정리하기
        조건: 정수의 길이는 2이상 10^5 이하
             정수의 배열 데이터 값은 -100,000 이상 100,000 이하
        */
        
        function solution() {
            arr.sort((a,b) => a - b);
            return arr;
            //sort 메서드는 아무런 조건을 전달하지 않고 실행하면 데이터가 문자열이라고 가정함
        }
        //sort() 메서드를 사용하지 않고 하는 방법


         /*
        배열 정의하기
        정수 배열을 하나 받습니다. 배열의 중복값을 제거하고 배열 데이터를 내림차순으로 정렬해서 반환하시오
        조건: 정수의 길이는 2이상 1000 이하
             정수의 배열 데이터 값은 -100,000 이상 100,000 이하

             중간값을 제거 해야하므로 delete로 없애기
        */
         solution = () => {
           const Arr = [...newSet(arr)];
           Arr.sort((a,b) => a - b);
            return Arr;
            //집합은 중복값을 허용하지 않으므로 요구하는 중복문제를 한번에 해결가능
            
        }
           /*
        두개 뽑아서 더하기 
        정수 배열을 number가 정해집니다. number에서 서로 다른 인덱스에 있는 2개의 수를 뽑아 더해 만들 수 있는 
        모든 수를 배열에 오름차순으로 담아 반환하는 함수를 구현해라 
        */
       solution = (number) => {
        const ret =[];
        for(let i =0; i <number.length; i++){
            for(let j =0; j<i; j++){
                ret.push(number[i] + number[j])
            }
        }
        return[...new Set(ret)].sort((a,b)=>a-b);
       }
        /*
        모의고사
        
        */
        function solution(answers) {
    const arr = [
        [1, 2, 3, 4, 5], 
        [2, 1, 2, 3, 2, 4, 2, 5], 
        [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]
    ];
    
    const scores = [0, 0, 0]; // 각 수포자의 점수를 저장할 배열
    const result = []; // 최종적으로 정답을 반환할 배열

    // 각 수포자의 점수를 계산
    for (let i = 0; i < answers.length; i++) {
        for (let j = 0; j < arr.length; j++) {
            if (answers[i] === arr[j][i % arr[j].length]) {
                scores[j]++;
            }
        }
    }

    // 가장 높은 점수를 찾음
    const maxScore = Math.max(...scores);

    // 가장 높은 점수를 받은 수포자(들)를 찾음
    for (let i = 0; i < scores.length; i++) {
        if (scores[i] === maxScore) {
            result.push(i + 1); // 수포자 번호는 1번부터 시작하므로 +1
        }
    }

    return result.sort((a, b) => a - b); // 오름차순으로 정렬하여 반환
}
     /*
        행렬의 곱셈
        행렬 arr1,arr2 행과 열의 깅이는 2이상 100 이하이다
        행렬 arr1,arr2의 데이터는 -10 이상 20 이하의 자연수 이다.
        곱할 수 있는 배열만 주어진다.
        */

        function solution(arr1,arr2) {
            const r1 = arr1.length;
            const c1 = arr[0].length;
            const r2 = arr2.length;
            const c2 = arr[0].length;
            
            //결과값 
            const arr =[];
            for (let i = 0; i < r1; i++) {
                arr.push(new Array(c2).fill(0));
            }
            //첫번째 행렬
            for (let i = 0; i < r1; i++) {
                for(let j =0; j <c2; j++){ //두번쨰 행렬 
                    for(let k = 0; k<c1; k++){
                        arr[i][j] += arr1[i][k] + arr2[k][j];
                    }
                }
                
            }
            return arr;
        }
        /*
        실패율
        */

        solution = (N,stages) => {
            const challenger = new Array(N +2).fill(0)
            for(const stage of stages) {
                challenger[stage] += 1;
            }
            const fails ={};
            let total = stages.length;

            for(let i =1; i<=N; i++){
                if(challenger[i] === 0){
                    fails[i] = 0;
                    continue;
                }
                fails[i] = challenger[i];
            }
            const result = Object.entries(false).sort((a, b)=>b[1]-a[1]);

            return result.map((v)=> Number(v[0]));
       }

        /*
        방문길이
        */
    </script>
</body>
</html>